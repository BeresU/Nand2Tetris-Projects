<class><keyword> class </keyword><identifier category="class" usage="class name"> Ball </identifier><symbol> { </symbol><classVarDec><keyword> field </keyword><keyword> int </keyword><identifier category="this" index="0" usage="this declaration"> x </identifier><symbol> , </symbol><identifier category="this" index="1" usage="this declaration"> y </identifier><symbol> ; </symbol></classVarDec><classVarDec><keyword> field </keyword><keyword> int </keyword><identifier category="this" index="2" usage="this declaration"> lengthx </identifier><symbol> , </symbol><identifier category="this" index="3" usage="this declaration"> lengthy </identifier><symbol> ; </symbol></classVarDec><classVarDec><keyword> field </keyword><keyword> int </keyword><identifier category="this" index="4" usage="this declaration"> d </identifier><symbol> , </symbol><identifier category="this" index="5" usage="this declaration"> straightD </identifier><symbol> , </symbol><identifier category="this" index="6" usage="this declaration"> diagonalD </identifier><symbol> ; </symbol></classVarDec><classVarDec><keyword> field </keyword><keyword> boolean </keyword><identifier category="this" index="7" usage="this declaration"> invert </identifier><symbol> , </symbol><identifier category="this" index="8" usage="this declaration"> positivex </identifier><symbol> , </symbol><identifier category="this" index="9" usage="this declaration"> positivey </identifier><symbol> ; </symbol></classVarDec><classVarDec><keyword> field </keyword><keyword> int </keyword><identifier category="this" index="10" usage="this declaration"> leftWall </identifier><symbol> , </symbol><identifier category="this" index="11" usage="this declaration"> rightWall </identifier><symbol> , </symbol><identifier category="this" index="12" usage="this declaration"> topWall </identifier><symbol> , </symbol><identifier category="this" index="13" usage="this declaration"> bottomWall </identifier><symbol> ; </symbol></classVarDec><classVarDec><keyword> field </keyword><keyword> int </keyword><identifier category="this" index="14" usage="this declaration"> wall </identifier><symbol> ; </symbol></classVarDec><subroutineDec><keyword> constructor </keyword><identifier> Ball </identifier><identifier category="subroutine" usage="subroutine declaration"> new </identifier><symbol> ( </symbol><parameterList><keyword> int </keyword><identifier category="argument" index="0" usage="parameter list"> Ax </identifier><symbol> , </symbol><keyword> int </keyword><identifier category="argument" index="1" usage="parameter list"> Ay </identifier><symbol> , </symbol><keyword> int </keyword><identifier category="argument" index="2" usage="parameter list"> AleftWall </identifier><symbol> , </symbol><keyword> int </keyword><identifier category="argument" index="3" usage="parameter list"> ArightWall </identifier><symbol> , </symbol><keyword> int </keyword><identifier category="argument" index="4" usage="parameter list"> AtopWall </identifier><symbol> , </symbol><keyword> int </keyword><identifier category="argument" index="5" usage="parameter list"> AbottomWall </identifier></parameterList><symbol> ) </symbol><subroutineBody><symbol> { </symbol><statements><letStatement><keyword> let </keyword><identifier category="this" index="0" usage="let"> x </identifier><symbol> = </symbol><expression><term><identifier category="argument" index="0" usage="expression use"> Ax </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="this" index="1" usage="let"> y </identifier><symbol> = </symbol><expression><term><identifier category="argument" index="1" usage="expression use"> Ay </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="this" index="10" usage="let"> leftWall </identifier><symbol> = </symbol><expression><term><identifier category="argument" index="2" usage="expression use"> AleftWall </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="this" index="11" usage="let"> rightWall </identifier><symbol> = </symbol><expression><term><identifier category="argument" index="3" usage="expression use"> ArightWall </identifier></term><symbol> - </symbol><term><integerConstant> 6 </integerConstant></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="this" index="12" usage="let"> topWall </identifier><symbol> = </symbol><expression><term><identifier category="argument" index="4" usage="expression use"> AtopWall </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="this" index="13" usage="let"> bottomWall </identifier><symbol> = </symbol><expression><term><identifier category="argument" index="5" usage="expression use"> AbottomWall </identifier></term><symbol> - </symbol><term><integerConstant> 6 </integerConstant></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="this" index="14" usage="let"> wall </identifier><symbol> = </symbol><expression><term><integerConstant> 0 </integerConstant></term></expression><symbol> ; </symbol></letStatement><doStatement><keyword> do </keyword><identifier category="subroutine" usage="do"> show </identifier><symbol> ( </symbol><expressionList></expressionList><symbol> ) </symbol><symbol> ; </symbol></doStatement><returnStatement><keyword> return </keyword><expression><term><keyword> this </keyword></term></expression><symbol> ; </symbol></returnStatement></statements><symbol> } </symbol></subroutineBody></subroutineDec><subroutineDec><keyword> method </keyword><keyword> void </keyword><identifier category="subroutine" usage="subroutine declaration"> dispose </identifier><symbol> ( </symbol><parameterList></parameterList><symbol> ) </symbol><subroutineBody><symbol> { </symbol><statements><doStatement><keyword> do </keyword><identifier category="class" usage="do"> Memory </identifier><symbol> . </symbol><identifier category="subroutine" usage="expression use"> deAlloc </identifier><symbol> ( </symbol><expressionList><expression><term><keyword> this </keyword></term></expression></expressionList><symbol> ) </symbol><symbol> ; </symbol></doStatement><returnStatement><keyword> return </keyword><symbol> ; </symbol></returnStatement></statements><symbol> } </symbol></subroutineBody></subroutineDec><subroutineDec><keyword> method </keyword><keyword> void </keyword><identifier category="subroutine" usage="subroutine declaration"> show </identifier><symbol> ( </symbol><parameterList></parameterList><symbol> ) </symbol><subroutineBody><symbol> { </symbol><statements><doStatement><keyword> do </keyword><identifier category="class" usage="do"> Screen </identifier><symbol> . </symbol><identifier category="subroutine" usage="expression use"> setColor </identifier><symbol> ( </symbol><expressionList><expression><term><keyword> true </keyword></term></expression></expressionList><symbol> ) </symbol><symbol> ; </symbol></doStatement><doStatement><keyword> do </keyword><identifier category="subroutine" usage="do"> draw </identifier><symbol> ( </symbol><expressionList></expressionList><symbol> ) </symbol><symbol> ; </symbol></doStatement><returnStatement><keyword> return </keyword><symbol> ; </symbol></returnStatement></statements><symbol> } </symbol></subroutineBody></subroutineDec><subroutineDec><keyword> method </keyword><keyword> void </keyword><identifier category="subroutine" usage="subroutine declaration"> hide </identifier><symbol> ( </symbol><parameterList></parameterList><symbol> ) </symbol><subroutineBody><symbol> { </symbol><statements><doStatement><keyword> do </keyword><identifier category="class" usage="do"> Screen </identifier><symbol> . </symbol><identifier category="subroutine" usage="expression use"> setColor </identifier><symbol> ( </symbol><expressionList><expression><term><keyword> false </keyword></term></expression></expressionList><symbol> ) </symbol><symbol> ; </symbol></doStatement><doStatement><keyword> do </keyword><identifier category="subroutine" usage="do"> draw </identifier><symbol> ( </symbol><expressionList></expressionList><symbol> ) </symbol><symbol> ; </symbol></doStatement><returnStatement><keyword> return </keyword><symbol> ; </symbol></returnStatement></statements><symbol> } </symbol></subroutineBody></subroutineDec><subroutineDec><keyword> method </keyword><keyword> void </keyword><identifier category="subroutine" usage="subroutine declaration"> draw </identifier><symbol> ( </symbol><parameterList></parameterList><symbol> ) </symbol><subroutineBody><symbol> { </symbol><statements><doStatement><keyword> do </keyword><identifier category="class" usage="do"> Screen </identifier><symbol> . </symbol><identifier category="subroutine" usage="expression use"> drawRectangle </identifier><symbol> ( </symbol><expressionList><expression><term><identifier category="this" index="0" usage="expression use"> x </identifier></term></expression><symbol> , </symbol><expression><term><identifier category="this" index="1" usage="expression use"> y </identifier></term></expression><symbol> , </symbol><expression><term><identifier category="this" index="0" usage="expression use"> x </identifier></term><symbol> + </symbol><term><integerConstant> 5 </integerConstant></term></expression><symbol> , </symbol><expression><term><identifier category="this" index="1" usage="expression use"> y </identifier></term><symbol> + </symbol><term><integerConstant> 5 </integerConstant></term></expression></expressionList><symbol> ) </symbol><symbol> ; </symbol></doStatement><returnStatement><keyword> return </keyword><symbol> ; </symbol></returnStatement></statements><symbol> } </symbol></subroutineBody></subroutineDec><subroutineDec><keyword> method </keyword><keyword> int </keyword><identifier category="subroutine" usage="subroutine declaration"> getLeft </identifier><symbol> ( </symbol><parameterList></parameterList><symbol> ) </symbol><subroutineBody><symbol> { </symbol><statements><returnStatement><keyword> return </keyword><expression><term><identifier category="this" index="0" usage="expression use"> x </identifier></term></expression><symbol> ; </symbol></returnStatement></statements><symbol> } </symbol></subroutineBody></subroutineDec><subroutineDec><keyword> method </keyword><keyword> int </keyword><identifier category="subroutine" usage="subroutine declaration"> getRight </identifier><symbol> ( </symbol><parameterList></parameterList><symbol> ) </symbol><subroutineBody><symbol> { </symbol><statements><returnStatement><keyword> return </keyword><expression><term><identifier category="this" index="0" usage="expression use"> x </identifier></term><symbol> + </symbol><term><integerConstant> 5 </integerConstant></term></expression><symbol> ; </symbol></returnStatement></statements><symbol> } </symbol></subroutineBody></subroutineDec><subroutineDec><keyword> method </keyword><keyword> void </keyword><identifier category="subroutine" usage="subroutine declaration"> setDestination </identifier><symbol> ( </symbol><parameterList><keyword> int </keyword><identifier category="argument" index="1" usage="parameter list"> destx </identifier><symbol> , </symbol><keyword> int </keyword><identifier category="argument" index="2" usage="parameter list"> desty </identifier></parameterList><symbol> ) </symbol><subroutineBody><symbol> { </symbol><varDec><keyword> var </keyword><keyword> int </keyword><identifier category="local" index="0" usage="subroutine variable declaration"> dx </identifier><symbol> , </symbol><identifier category="local" index="1" usage="subroutine variable declaration"> dy </identifier><symbol> , </symbol><identifier category="local" index="2" usage="subroutine variable declaration"> temp </identifier><symbol> ; </symbol></varDec><statements><letStatement><keyword> let </keyword><identifier category="this" index="2" usage="let"> lengthx </identifier><symbol> = </symbol><expression><term><identifier category="argument" index="1" usage="expression use"> destx </identifier></term><symbol> - </symbol><term><identifier category="this" index="0" usage="expression use"> x </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="this" index="3" usage="let"> lengthy </identifier><symbol> = </symbol><expression><term><identifier category="argument" index="2" usage="expression use"> desty </identifier></term><symbol> - </symbol><term><identifier category="this" index="1" usage="expression use"> y </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="local" index="0" usage="let"> dx </identifier><symbol> = </symbol><expression><term><identifier category="class" usage="expression use"> Math </identifier><symbol> . </symbol><identifier category="subroutine" usage="expression use"> abs </identifier><symbol> ( </symbol><expressionList><expression><term><identifier category="this" index="2" usage="expression use"> lengthx </identifier></term></expression></expressionList><symbol> ) </symbol></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="local" index="1" usage="let"> dy </identifier><symbol> = </symbol><expression><term><identifier category="class" usage="expression use"> Math </identifier><symbol> . </symbol><identifier category="subroutine" usage="expression use"> abs </identifier><symbol> ( </symbol><expressionList><expression><term><identifier category="this" index="3" usage="expression use"> lengthy </identifier></term></expression></expressionList><symbol> ) </symbol></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="this" index="7" usage="let"> invert </identifier><symbol> = </symbol><expression><term><symbol> ( </symbol><expression><term><identifier category="local" index="0" usage="expression use"> dx </identifier></term><symbol> &lt; </symbol><term><identifier category="local" index="1" usage="expression use"> dy </identifier></term></expression><symbol> ) </symbol></term></expression><symbol> ; </symbol></letStatement><ifStatement><keyword> if </keyword><symbol> ( </symbol><expression><term><identifier category="this" index="7" usage="expression use"> invert </identifier></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> let </keyword><identifier category="local" index="2" usage="let"> temp </identifier><symbol> = </symbol><expression><term><identifier category="local" index="0" usage="expression use"> dx </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="local" index="0" usage="let"> dx </identifier><symbol> = </symbol><expression><term><identifier category="local" index="1" usage="expression use"> dy </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="local" index="1" usage="let"> dy </identifier><symbol> = </symbol><expression><term><identifier category="local" index="2" usage="expression use"> temp </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="this" index="8" usage="let"> positivex </identifier><symbol> = </symbol><expression><term><symbol> ( </symbol><expression><term><identifier category="this" index="1" usage="expression use"> y </identifier></term><symbol> &lt; </symbol><term><identifier category="argument" index="2" usage="expression use"> desty </identifier></term></expression><symbol> ) </symbol></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="this" index="9" usage="let"> positivey </identifier><symbol> = </symbol><expression><term><symbol> ( </symbol><expression><term><identifier category="this" index="0" usage="expression use"> x </identifier></term><symbol> &lt; </symbol><term><identifier category="argument" index="1" usage="expression use"> destx </identifier></term></expression><symbol> ) </symbol></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol><keyword> else </keyword><symbol> { </symbol><statements><letStatement><keyword> let </keyword><identifier category="this" index="8" usage="let"> positivex </identifier><symbol> = </symbol><expression><term><symbol> ( </symbol><expression><term><identifier category="this" index="0" usage="expression use"> x </identifier></term><symbol> &lt; </symbol><term><identifier category="argument" index="1" usage="expression use"> destx </identifier></term></expression><symbol> ) </symbol></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="this" index="9" usage="let"> positivey </identifier><symbol> = </symbol><expression><term><symbol> ( </symbol><expression><term><identifier category="this" index="1" usage="expression use"> y </identifier></term><symbol> &lt; </symbol><term><identifier category="argument" index="2" usage="expression use"> desty </identifier></term></expression><symbol> ) </symbol></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol></ifStatement><letStatement><keyword> let </keyword><identifier category="this" index="4" usage="let"> d </identifier><symbol> = </symbol><expression><term><symbol> ( </symbol><expression><term><integerConstant> 2 </integerConstant></term><symbol> * </symbol><term><identifier category="local" index="1" usage="expression use"> dy </identifier></term></expression><symbol> ) </symbol></term><symbol> - </symbol><term><identifier category="local" index="0" usage="expression use"> dx </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="this" index="5" usage="let"> straightD </identifier><symbol> = </symbol><expression><term><integerConstant> 2 </integerConstant></term><symbol> * </symbol><term><identifier category="local" index="1" usage="expression use"> dy </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="this" index="6" usage="let"> diagonalD </identifier><symbol> = </symbol><expression><term><integerConstant> 2 </integerConstant></term><symbol> * </symbol><term><symbol> ( </symbol><expression><term><identifier category="local" index="1" usage="expression use"> dy </identifier></term><symbol> - </symbol><term><identifier category="local" index="0" usage="expression use"> dx </identifier></term></expression><symbol> ) </symbol></term></expression><symbol> ; </symbol></letStatement><returnStatement><keyword> return </keyword><symbol> ; </symbol></returnStatement></statements><symbol> } </symbol></subroutineBody></subroutineDec><subroutineDec><keyword> method </keyword><keyword> int </keyword><identifier category="subroutine" usage="subroutine declaration"> move </identifier><symbol> ( </symbol><parameterList></parameterList><symbol> ) </symbol><subroutineBody><symbol> { </symbol><statements><doStatement><keyword> do </keyword><identifier category="subroutine" usage="do"> hide </identifier><symbol> ( </symbol><expressionList></expressionList><symbol> ) </symbol><symbol> ; </symbol></doStatement><ifStatement><keyword> if </keyword><symbol> ( </symbol><expression><term><identifier category="this" index="4" usage="expression use"> d </identifier></term><symbol> &lt; </symbol><term><integerConstant> 0 </integerConstant></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> let </keyword><identifier category="this" index="4" usage="let"> d </identifier><symbol> = </symbol><expression><term><identifier category="this" index="4" usage="expression use"> d </identifier></term><symbol> + </symbol><term><identifier category="this" index="5" usage="expression use"> straightD </identifier></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol><keyword> else </keyword><symbol> { </symbol><statements><letStatement><keyword> let </keyword><identifier category="this" index="4" usage="let"> d </identifier><symbol> = </symbol><expression><term><identifier category="this" index="4" usage="expression use"> d </identifier></term><symbol> + </symbol><term><identifier category="this" index="6" usage="expression use"> diagonalD </identifier></term></expression><symbol> ; </symbol></letStatement><ifStatement><keyword> if </keyword><symbol> ( </symbol><expression><term><identifier category="this" index="9" usage="expression use"> positivey </identifier></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><ifStatement><keyword> if </keyword><symbol> ( </symbol><expression><term><identifier category="this" index="7" usage="expression use"> invert </identifier></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> let </keyword><identifier category="this" index="0" usage="let"> x </identifier><symbol> = </symbol><expression><term><identifier category="this" index="0" usage="expression use"> x </identifier></term><symbol> + </symbol><term><integerConstant> 4 </integerConstant></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol><keyword> else </keyword><symbol> { </symbol><statements><letStatement><keyword> let </keyword><identifier category="this" index="1" usage="let"> y </identifier><symbol> = </symbol><expression><term><identifier category="this" index="1" usage="expression use"> y </identifier></term><symbol> + </symbol><term><integerConstant> 4 </integerConstant></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol></ifStatement></statements><symbol> } </symbol><keyword> else </keyword><symbol> { </symbol><statements><ifStatement><keyword> if </keyword><symbol> ( </symbol><expression><term><identifier category="this" index="7" usage="expression use"> invert </identifier></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> let </keyword><identifier category="this" index="0" usage="let"> x </identifier><symbol> = </symbol><expression><term><identifier category="this" index="0" usage="expression use"> x </identifier></term><symbol> - </symbol><term><integerConstant> 4 </integerConstant></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol><keyword> else </keyword><symbol> { </symbol><statements><letStatement><keyword> let </keyword><identifier category="this" index="1" usage="let"> y </identifier><symbol> = </symbol><expression><term><identifier category="this" index="1" usage="expression use"> y </identifier></term><symbol> - </symbol><term><integerConstant> 4 </integerConstant></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol></ifStatement></statements><symbol> } </symbol></ifStatement></statements><symbol> } </symbol></ifStatement><ifStatement><keyword> if </keyword><symbol> ( </symbol><expression><term><identifier category="this" index="8" usage="expression use"> positivex </identifier></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><ifStatement><keyword> if </keyword><symbol> ( </symbol><expression><term><identifier category="this" index="7" usage="expression use"> invert </identifier></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> let </keyword><identifier category="this" index="1" usage="let"> y </identifier><symbol> = </symbol><expression><term><identifier category="this" index="1" usage="expression use"> y </identifier></term><symbol> + </symbol><term><integerConstant> 4 </integerConstant></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol><keyword> else </keyword><symbol> { </symbol><statements><letStatement><keyword> let </keyword><identifier category="this" index="0" usage="let"> x </identifier><symbol> = </symbol><expression><term><identifier category="this" index="0" usage="expression use"> x </identifier></term><symbol> + </symbol><term><integerConstant> 4 </integerConstant></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol></ifStatement></statements><symbol> } </symbol><keyword> else </keyword><symbol> { </symbol><statements><ifStatement><keyword> if </keyword><symbol> ( </symbol><expression><term><identifier category="this" index="7" usage="expression use"> invert </identifier></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> let </keyword><identifier category="this" index="1" usage="let"> y </identifier><symbol> = </symbol><expression><term><identifier category="this" index="1" usage="expression use"> y </identifier></term><symbol> - </symbol><term><integerConstant> 4 </integerConstant></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol><keyword> else </keyword><symbol> { </symbol><statements><letStatement><keyword> let </keyword><identifier category="this" index="0" usage="let"> x </identifier><symbol> = </symbol><expression><term><identifier category="this" index="0" usage="expression use"> x </identifier></term><symbol> - </symbol><term><integerConstant> 4 </integerConstant></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol></ifStatement></statements><symbol> } </symbol></ifStatement><ifStatement><keyword> if </keyword><symbol> ( </symbol><expression><term><symbol> ~ </symbol><term><symbol> ( </symbol><expression><term><identifier category="this" index="0" usage="expression use"> x </identifier></term><symbol> &gt; </symbol><term><identifier category="this" index="10" usage="expression use"> leftWall </identifier></term></expression><symbol> ) </symbol></term></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> let </keyword><identifier category="this" index="14" usage="let"> wall </identifier><symbol> = </symbol><expression><term><integerConstant> 1 </integerConstant></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="this" index="0" usage="let"> x </identifier><symbol> = </symbol><expression><term><identifier category="this" index="10" usage="expression use"> leftWall </identifier></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol></ifStatement><ifStatement><keyword> if </keyword><symbol> ( </symbol><expression><term><symbol> ~ </symbol><term><symbol> ( </symbol><expression><term><identifier category="this" index="0" usage="expression use"> x </identifier></term><symbol> &lt; </symbol><term><identifier category="this" index="11" usage="expression use"> rightWall </identifier></term></expression><symbol> ) </symbol></term></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> let </keyword><identifier category="this" index="14" usage="let"> wall </identifier><symbol> = </symbol><expression><term><integerConstant> 2 </integerConstant></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="this" index="0" usage="let"> x </identifier><symbol> = </symbol><expression><term><identifier category="this" index="11" usage="expression use"> rightWall </identifier></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol></ifStatement><ifStatement><keyword> if </keyword><symbol> ( </symbol><expression><term><symbol> ~ </symbol><term><symbol> ( </symbol><expression><term><identifier category="this" index="1" usage="expression use"> y </identifier></term><symbol> &gt; </symbol><term><identifier category="this" index="12" usage="expression use"> topWall </identifier></term></expression><symbol> ) </symbol></term></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> let </keyword><identifier category="this" index="14" usage="let"> wall </identifier><symbol> = </symbol><expression><term><integerConstant> 3 </integerConstant></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="this" index="1" usage="let"> y </identifier><symbol> = </symbol><expression><term><identifier category="this" index="12" usage="expression use"> topWall </identifier></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol></ifStatement><ifStatement><keyword> if </keyword><symbol> ( </symbol><expression><term><symbol> ~ </symbol><term><symbol> ( </symbol><expression><term><identifier category="this" index="1" usage="expression use"> y </identifier></term><symbol> &lt; </symbol><term><identifier category="this" index="13" usage="expression use"> bottomWall </identifier></term></expression><symbol> ) </symbol></term></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> let </keyword><identifier category="this" index="14" usage="let"> wall </identifier><symbol> = </symbol><expression><term><integerConstant> 4 </integerConstant></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="this" index="1" usage="let"> y </identifier><symbol> = </symbol><expression><term><identifier category="this" index="13" usage="expression use"> bottomWall </identifier></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol></ifStatement><doStatement><keyword> do </keyword><identifier category="subroutine" usage="do"> show </identifier><symbol> ( </symbol><expressionList></expressionList><symbol> ) </symbol><symbol> ; </symbol></doStatement><returnStatement><keyword> return </keyword><expression><term><identifier category="this" index="14" usage="expression use"> wall </identifier></term></expression><symbol> ; </symbol></returnStatement></statements><symbol> } </symbol></subroutineBody></subroutineDec><subroutineDec><keyword> method </keyword><keyword> void </keyword><identifier category="subroutine" usage="subroutine declaration"> bounce </identifier><symbol> ( </symbol><parameterList><keyword> int </keyword><identifier category="argument" index="1" usage="parameter list"> bouncingDirection </identifier></parameterList><symbol> ) </symbol><subroutineBody><symbol> { </symbol><varDec><keyword> var </keyword><keyword> int </keyword><identifier category="local" index="0" usage="subroutine variable declaration"> newx </identifier><symbol> , </symbol><identifier category="local" index="1" usage="subroutine variable declaration"> newy </identifier><symbol> , </symbol><identifier category="local" index="2" usage="subroutine variable declaration"> divLengthx </identifier><symbol> , </symbol><identifier category="local" index="3" usage="subroutine variable declaration"> divLengthy </identifier><symbol> , </symbol><identifier category="local" index="4" usage="subroutine variable declaration"> factor </identifier><symbol> ; </symbol></varDec><statements><letStatement><keyword> let </keyword><identifier category="local" index="2" usage="let"> divLengthx </identifier><symbol> = </symbol><expression><term><identifier category="this" index="2" usage="expression use"> lengthx </identifier></term><symbol> / </symbol><term><integerConstant> 10 </integerConstant></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="local" index="3" usage="let"> divLengthy </identifier><symbol> = </symbol><expression><term><identifier category="this" index="3" usage="expression use"> lengthy </identifier></term><symbol> / </symbol><term><integerConstant> 10 </integerConstant></term></expression><symbol> ; </symbol></letStatement><ifStatement><keyword> if </keyword><symbol> ( </symbol><expression><term><identifier category="argument" index="1" usage="expression use"> bouncingDirection </identifier></term><symbol> = </symbol><term><integerConstant> 0 </integerConstant></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> let </keyword><identifier category="local" index="4" usage="let"> factor </identifier><symbol> = </symbol><expression><term><integerConstant> 10 </integerConstant></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol><keyword> else </keyword><symbol> { </symbol><statements><ifStatement><keyword> if </keyword><symbol> ( </symbol><expression><term><symbol> ( </symbol><expression><term><symbol> ( </symbol><expression><term><symbol> ~ </symbol><term><symbol> ( </symbol><expression><term><identifier category="this" index="2" usage="expression use"> lengthx </identifier></term><symbol> &lt; </symbol><term><integerConstant> 0 </integerConstant></term></expression><symbol> ) </symbol></term></term></expression><symbol> ) </symbol></term><symbol> &amp; </symbol><term><symbol> ( </symbol><expression><term><identifier category="argument" index="1" usage="expression use"> bouncingDirection </identifier></term><symbol> = </symbol><term><integerConstant> 1 </integerConstant></term></expression><symbol> ) </symbol></term></expression><symbol> ) </symbol></term><symbol> | </symbol><term><symbol> ( </symbol><expression><term><symbol> ( </symbol><expression><term><identifier category="this" index="2" usage="expression use"> lengthx </identifier></term><symbol> &lt; </symbol><term><integerConstant> 0 </integerConstant></term></expression><symbol> ) </symbol></term><symbol> &amp; </symbol><term><symbol> ( </symbol><expression><term><identifier category="argument" index="1" usage="expression use"> bouncingDirection </identifier></term><symbol> = </symbol><term><symbol> ( </symbol><expression><term><symbol> - </symbol><term><integerConstant> 1 </integerConstant></term></term></expression><symbol> ) </symbol></term></expression><symbol> ) </symbol></term></expression><symbol> ) </symbol></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> let </keyword><identifier category="local" index="4" usage="let"> factor </identifier><symbol> = </symbol><expression><term><integerConstant> 20 </integerConstant></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol><keyword> else </keyword><symbol> { </symbol><statements><letStatement><keyword> let </keyword><identifier category="local" index="4" usage="let"> factor </identifier><symbol> = </symbol><expression><term><integerConstant> 5 </integerConstant></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol></ifStatement></statements><symbol> } </symbol></ifStatement><ifStatement><keyword> if </keyword><symbol> ( </symbol><expression><term><identifier category="this" index="14" usage="expression use"> wall </identifier></term><symbol> = </symbol><term><integerConstant> 1 </integerConstant></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> let </keyword><identifier category="local" index="0" usage="let"> newx </identifier><symbol> = </symbol><expression><term><integerConstant> 506 </integerConstant></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="local" index="1" usage="let"> newy </identifier><symbol> = </symbol><expression><term><symbol> ( </symbol><expression><term><identifier category="local" index="3" usage="expression use"> divLengthy </identifier></term><symbol> * </symbol><term><symbol> ( </symbol><expression><term><symbol> - </symbol><term><integerConstant> 50 </integerConstant></term></term></expression><symbol> ) </symbol></term></expression><symbol> ) </symbol></term><symbol> / </symbol><term><identifier category="local" index="2" usage="expression use"> divLengthx </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="local" index="1" usage="let"> newy </identifier><symbol> = </symbol><expression><term><identifier category="this" index="1" usage="expression use"> y </identifier></term><symbol> + </symbol><term><symbol> ( </symbol><expression><term><identifier category="local" index="1" usage="expression use"> newy </identifier></term><symbol> * </symbol><term><identifier category="local" index="4" usage="expression use"> factor </identifier></term></expression><symbol> ) </symbol></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol><keyword> else </keyword><symbol> { </symbol><statements><ifStatement><keyword> if </keyword><symbol> ( </symbol><expression><term><identifier category="this" index="14" usage="expression use"> wall </identifier></term><symbol> = </symbol><term><integerConstant> 2 </integerConstant></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> let </keyword><identifier category="local" index="0" usage="let"> newx </identifier><symbol> = </symbol><expression><term><integerConstant> 0 </integerConstant></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="local" index="1" usage="let"> newy </identifier><symbol> = </symbol><expression><term><symbol> ( </symbol><expression><term><identifier category="local" index="3" usage="expression use"> divLengthy </identifier></term><symbol> * </symbol><term><integerConstant> 50 </integerConstant></term></expression><symbol> ) </symbol></term><symbol> / </symbol><term><identifier category="local" index="2" usage="expression use"> divLengthx </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="local" index="1" usage="let"> newy </identifier><symbol> = </symbol><expression><term><identifier category="this" index="1" usage="expression use"> y </identifier></term><symbol> + </symbol><term><symbol> ( </symbol><expression><term><identifier category="local" index="1" usage="expression use"> newy </identifier></term><symbol> * </symbol><term><identifier category="local" index="4" usage="expression use"> factor </identifier></term></expression><symbol> ) </symbol></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol><keyword> else </keyword><symbol> { </symbol><statements><ifStatement><keyword> if </keyword><symbol> ( </symbol><expression><term><identifier category="this" index="14" usage="expression use"> wall </identifier></term><symbol> = </symbol><term><integerConstant> 3 </integerConstant></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> let </keyword><identifier category="local" index="1" usage="let"> newy </identifier><symbol> = </symbol><expression><term><integerConstant> 250 </integerConstant></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="local" index="0" usage="let"> newx </identifier><symbol> = </symbol><expression><term><symbol> ( </symbol><expression><term><identifier category="local" index="2" usage="expression use"> divLengthx </identifier></term><symbol> * </symbol><term><symbol> ( </symbol><expression><term><symbol> - </symbol><term><integerConstant> 25 </integerConstant></term></term></expression><symbol> ) </symbol></term></expression><symbol> ) </symbol></term><symbol> / </symbol><term><identifier category="local" index="3" usage="expression use"> divLengthy </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="local" index="0" usage="let"> newx </identifier><symbol> = </symbol><expression><term><identifier category="this" index="0" usage="expression use"> x </identifier></term><symbol> + </symbol><term><symbol> ( </symbol><expression><term><identifier category="local" index="0" usage="expression use"> newx </identifier></term><symbol> * </symbol><term><identifier category="local" index="4" usage="expression use"> factor </identifier></term></expression><symbol> ) </symbol></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol><keyword> else </keyword><symbol> { </symbol><statements><letStatement><keyword> let </keyword><identifier category="local" index="1" usage="let"> newy </identifier><symbol> = </symbol><expression><term><integerConstant> 0 </integerConstant></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="local" index="0" usage="let"> newx </identifier><symbol> = </symbol><expression><term><symbol> ( </symbol><expression><term><identifier category="local" index="2" usage="expression use"> divLengthx </identifier></term><symbol> * </symbol><term><integerConstant> 25 </integerConstant></term></expression><symbol> ) </symbol></term><symbol> / </symbol><term><identifier category="local" index="3" usage="expression use"> divLengthy </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> let </keyword><identifier category="local" index="0" usage="let"> newx </identifier><symbol> = </symbol><expression><term><identifier category="this" index="0" usage="expression use"> x </identifier></term><symbol> + </symbol><term><symbol> ( </symbol><expression><term><identifier category="local" index="0" usage="expression use"> newx </identifier></term><symbol> * </symbol><term><identifier category="local" index="4" usage="expression use"> factor </identifier></term></expression><symbol> ) </symbol></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol></ifStatement></statements><symbol> } </symbol></ifStatement></statements><symbol> } </symbol></ifStatement><doStatement><keyword> do </keyword><identifier category="subroutine" usage="do"> setDestination </identifier><symbol> ( </symbol><expressionList><expression><term><identifier category="local" index="0" usage="expression use"> newx </identifier></term></expression><symbol> , </symbol><expression><term><identifier category="local" index="1" usage="expression use"> newy </identifier></term></expression></expressionList><symbol> ) </symbol><symbol> ; </symbol></doStatement><returnStatement><keyword> return </keyword><symbol> ; </symbol></returnStatement></statements><symbol> } </symbol></subroutineBody></subroutineDec><symbol> } </symbol></class>